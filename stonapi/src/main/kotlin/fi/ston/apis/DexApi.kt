/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package fi.ston.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import fi.ston.models.DexReverseSimulateSwap200Response
import fi.ston.models.DexSwapStatus200Response
import fi.ston.models.GetAssetList200Response
import fi.ston.models.GetFarmList200Response
import fi.ston.models.GetPoolList200Response

import com.squareup.moshi.Json

import fi.ston.infrastructure.ApiClient
import fi.ston.infrastructure.ApiResponse
import fi.ston.infrastructure.ClientException
import fi.ston.infrastructure.ClientError
import fi.ston.infrastructure.ServerException
import fi.ston.infrastructure.ServerError
import fi.ston.infrastructure.MultiValueMap
import fi.ston.infrastructure.PartConfig
import fi.ston.infrastructure.RequestConfig
import fi.ston.infrastructure.RequestMethod
import fi.ston.infrastructure.ResponseType
import fi.ston.infrastructure.Success
import fi.ston.infrastructure.toMultiValue

class DexApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * 
     * 
     * @param offerAddress The address of the token we want to sell
     * @param askAddress The address of the token we want to buy
     * @param units Number of token units we want to sell
     * @param slippageTolerance The maximum possible difference between the rates that we expect and which will actually be, in fractions (for example, 0.001 is 0.1%)
     * @param referralAddress Referral address (optional)
     * @return DexReverseSimulateSwap200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun dexReverseSimulateSwap(offerAddress: kotlin.String, askAddress: kotlin.String, units: kotlin.String, slippageTolerance: kotlin.String, referralAddress: kotlin.String? = null) : DexReverseSimulateSwap200Response {
        val localVarResponse = dexReverseSimulateSwapWithHttpInfo(offerAddress = offerAddress, askAddress = askAddress, units = units, slippageTolerance = slippageTolerance, referralAddress = referralAddress)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DexReverseSimulateSwap200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param offerAddress The address of the token we want to sell
     * @param askAddress The address of the token we want to buy
     * @param units Number of token units we want to sell
     * @param slippageTolerance The maximum possible difference between the rates that we expect and which will actually be, in fractions (for example, 0.001 is 0.1%)
     * @param referralAddress Referral address (optional)
     * @return ApiResponse<DexReverseSimulateSwap200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun dexReverseSimulateSwapWithHttpInfo(offerAddress: kotlin.String, askAddress: kotlin.String, units: kotlin.String, slippageTolerance: kotlin.String, referralAddress: kotlin.String?) : ApiResponse<DexReverseSimulateSwap200Response?> {
        val localVariableConfig = dexReverseSimulateSwapRequestConfig(offerAddress = offerAddress, askAddress = askAddress, units = units, slippageTolerance = slippageTolerance, referralAddress = referralAddress)

        return request<Unit, DexReverseSimulateSwap200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation dexReverseSimulateSwap
     *
     * @param offerAddress The address of the token we want to sell
     * @param askAddress The address of the token we want to buy
     * @param units Number of token units we want to sell
     * @param slippageTolerance The maximum possible difference between the rates that we expect and which will actually be, in fractions (for example, 0.001 is 0.1%)
     * @param referralAddress Referral address (optional)
     * @return RequestConfig
     */
    fun dexReverseSimulateSwapRequestConfig(offerAddress: kotlin.String, askAddress: kotlin.String, units: kotlin.String, slippageTolerance: kotlin.String, referralAddress: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("offer_address", listOf(offerAddress.toString()))
                put("ask_address", listOf(askAddress.toString()))
                put("units", listOf(units.toString()))
                put("slippage_tolerance", listOf(slippageTolerance.toString()))
                if (referralAddress != null) {
                    put("referral_address", listOf(referralAddress.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/reverse_swap/simulate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param offerAddress The address of the token we want to sell
     * @param askAddress The address of the token we want to buy
     * @param units Number of token units we want to sell
     * @param slippageTolerance The maximum possible difference between the rates that we expect and which will actually be, in fractions (for example, 0.001 is 0.1%)
     * @param referralAddress Referral address (optional)
     * @return DexReverseSimulateSwap200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun dexSimulateSwap(offerAddress: kotlin.String, askAddress: kotlin.String, units: kotlin.String, slippageTolerance: kotlin.String, referralAddress: kotlin.String? = null) : DexReverseSimulateSwap200Response {
        val localVarResponse = dexSimulateSwapWithHttpInfo(offerAddress = offerAddress, askAddress = askAddress, units = units, slippageTolerance = slippageTolerance, referralAddress = referralAddress)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DexReverseSimulateSwap200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param offerAddress The address of the token we want to sell
     * @param askAddress The address of the token we want to buy
     * @param units Number of token units we want to sell
     * @param slippageTolerance The maximum possible difference between the rates that we expect and which will actually be, in fractions (for example, 0.001 is 0.1%)
     * @param referralAddress Referral address (optional)
     * @return ApiResponse<DexReverseSimulateSwap200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun dexSimulateSwapWithHttpInfo(offerAddress: kotlin.String, askAddress: kotlin.String, units: kotlin.String, slippageTolerance: kotlin.String, referralAddress: kotlin.String?) : ApiResponse<DexReverseSimulateSwap200Response?> {
        val localVariableConfig = dexSimulateSwapRequestConfig(offerAddress = offerAddress, askAddress = askAddress, units = units, slippageTolerance = slippageTolerance, referralAddress = referralAddress)

        return request<Unit, DexReverseSimulateSwap200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation dexSimulateSwap
     *
     * @param offerAddress The address of the token we want to sell
     * @param askAddress The address of the token we want to buy
     * @param units Number of token units we want to sell
     * @param slippageTolerance The maximum possible difference between the rates that we expect and which will actually be, in fractions (for example, 0.001 is 0.1%)
     * @param referralAddress Referral address (optional)
     * @return RequestConfig
     */
    fun dexSimulateSwapRequestConfig(offerAddress: kotlin.String, askAddress: kotlin.String, units: kotlin.String, slippageTolerance: kotlin.String, referralAddress: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("offer_address", listOf(offerAddress.toString()))
                put("ask_address", listOf(askAddress.toString()))
                put("units", listOf(units.toString()))
                put("slippage_tolerance", listOf(slippageTolerance.toString()))
                if (referralAddress != null) {
                    put("referral_address", listOf(referralAddress.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/swap/simulate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param routerAddress Address of the operation router
     * @param ownerAddress Owner&#x60;s wallet address
     * @param queryId Id of operation status query
     * @return DexSwapStatus200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun dexSwapStatus(routerAddress: kotlin.String, ownerAddress: kotlin.String, queryId: kotlin.String) : DexSwapStatus200Response {
        val localVarResponse = dexSwapStatusWithHttpInfo(routerAddress = routerAddress, ownerAddress = ownerAddress, queryId = queryId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DexSwapStatus200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param routerAddress Address of the operation router
     * @param ownerAddress Owner&#x60;s wallet address
     * @param queryId Id of operation status query
     * @return ApiResponse<DexSwapStatus200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun dexSwapStatusWithHttpInfo(routerAddress: kotlin.String, ownerAddress: kotlin.String, queryId: kotlin.String) : ApiResponse<DexSwapStatus200Response?> {
        val localVariableConfig = dexSwapStatusRequestConfig(routerAddress = routerAddress, ownerAddress = ownerAddress, queryId = queryId)

        return request<Unit, DexSwapStatus200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation dexSwapStatus
     *
     * @param routerAddress Address of the operation router
     * @param ownerAddress Owner&#x60;s wallet address
     * @param queryId Id of operation status query
     * @return RequestConfig
     */
    fun dexSwapStatusRequestConfig(routerAddress: kotlin.String, ownerAddress: kotlin.String, queryId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("router_address", listOf(routerAddress.toString()))
                put("owner_address", listOf(ownerAddress.toString()))
                put("query_id", listOf(queryId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/swap/status",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @return GetAssetList200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAssetList() : GetAssetList200Response {
        val localVarResponse = getAssetListWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetAssetList200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @return ApiResponse<GetAssetList200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAssetListWithHttpInfo() : ApiResponse<GetAssetList200Response?> {
        val localVariableConfig = getAssetListRequestConfig()

        return request<Unit, GetAssetList200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAssetList
     *
     * @return RequestConfig
     */
    fun getAssetListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/assets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @return GetFarmList200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getFarmList() : GetFarmList200Response {
        val localVarResponse = getFarmListWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetFarmList200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @return ApiResponse<GetFarmList200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getFarmListWithHttpInfo() : ApiResponse<GetFarmList200Response?> {
        val localVariableConfig = getFarmListRequestConfig()

        return request<Unit, GetFarmList200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getFarmList
     *
     * @return RequestConfig
     */
    fun getFarmListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/farms",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @return GetPoolList200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPoolList() : GetPoolList200Response {
        val localVarResponse = getPoolListWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetPoolList200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @return ApiResponse<GetPoolList200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPoolListWithHttpInfo() : ApiResponse<GetPoolList200Response?> {
        val localVariableConfig = getPoolListRequestConfig()

        return request<Unit, GetPoolList200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPoolList
     *
     * @return RequestConfig
     */
    fun getPoolListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/pools",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
